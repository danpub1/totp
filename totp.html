<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta name="description" content="totp - time-based one-time password">
        <meta name="author" content="">
        <title>totp - time-based one-time password</title>

        <style>
            body {
                font-family: 'Fira Mono', 'Fira Code', Cousine, Consolas, 'Courier New', 'Lucida Sans Typewriter', Monaco, 'Andale Mono', Courier, monospace; 
                font-size: 15px; 
                text-align: left; 
                line-height: 1.30;
                font-variant-ligatures: none;
            }
            .leader { font-size: 15px; }
            .spacer { font-size: 9px; }
            .footer { font-size: 13px; }
            .bodydiv { margin:0 auto; width:800px; }
            .title {  margin-bottom:0; margin-top:0 }
        </style>
    </head>
    <body>
        <div class="bodydiv" >
            <h2 class="title">totp</h2>
            <b class="leader">Time-based One-Time Password</b>
            <div class="spacer">&nbsp;</div>
            <div><b>Secret:&nbsp;&nbsp;&nbsp;</b> <input id="secret" type="text" value="" size="40"/></div>
            <div><b>HMAC:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</b> <select name="hmac" id="hmac">
                <option value="SHA-1">SHA-1</option>
                <option value="SHA-256">SHA-256</option>
                <option value="SHA-512">SHA-512</option>
            </select></div>
            <div><b>Length:&nbsp;&nbsp;&nbsp;</b> <input id="codeLen" type="text" value="6" size="1"/></div>
            <div><b>Window:&nbsp;&nbsp;&nbsp;</b> <input id="windowSize" type="text" value="30" size="4"/></div>
            <div><b>Remaining:</b> <span id="remaining"></span></div>
            <div><b>Code:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</b> <span id="code"></span></div>
            <div class="spacer">&nbsp;</div>
            <div class="footer">&copy; 2021 danpub1, <a href="https://github.com/danpub1/totp">repository on github</a></div>
            <div class="footer">Based on <a href="https://gist.github.com/rafaelsq/e6a84d2f9b487917115362e39032d528">https://gist.github.com/rafaelsq/e6a84d2f9b487917115362e39032d528</a></div>
        <div>
        <script>
var runes = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ234567abcdefghijklmnopqrstuvwxyz234567'

function encodeBuf(buf) {
   var encoded = ''
   var bitCount = buf.length * 8;
   var ii = 0;
   for (ii = 0; ii < bitCount; ii += 5) {
      switch (ii % 8) {
	     case 0: encoded += runes[((buf[Math.floor(ii / 8)] >> 3) & 0x1F)]; break; // bits 3-7
		 case 1: encoded += runes[((buf[Math.floor(ii / 8)] >> 2) & 0x1F)]; break; // bits 2-6
		 case 2: encoded += runes[((buf[Math.floor(ii / 8)] >> 1) & 0x1F)]; break; // bits 1-5
		 case 3: encoded += runes[((buf[Math.floor(ii / 8)] >> 0) & 0x1F)]; break; // bits 0-4
		 case 4: encoded += runes[((buf[Math.floor(ii / 8)] & 0x0F) << 1) + (ii + 5 < bitCount ? ((buf[Math.floor((ii + 5) / 8)] >> 7) & 0x01) : 0)]; break; // bits 0-3 + bit 7
		 case 5: encoded += runes[((buf[Math.floor(ii / 8)] & 0x07) << 2) + (ii + 5 < bitCount ? ((buf[Math.floor((ii + 5) / 8)] >> 6) & 0x03) : 0)]; break; // bits 0-2 + bit 6-7
		 case 6: encoded += runes[((buf[Math.floor(ii / 8)] & 0x03) << 3) + (ii + 5 < bitCount ? ((buf[Math.floor((ii + 5) / 8)] >> 5) & 0x07) : 0)]; break; // bits 0-1 + bit 5-7
		 case 7: encoded += runes[((buf[Math.floor(ii / 8)] & 0x01) << 4) + (ii + 5 < bitCount ? ((buf[Math.floor((ii + 5) / 8)] >> 4) & 0x0F) : 0)]; break; // bit 0 + bit 4-7
	  }
   }
   
   return encoded;
}

function decodeBuf(encoded) {
   var bitCount = Math.floor(encoded.length * 5 / 8) * 8;
   var buf = new Uint8Array(bitCount / 8);
   for (ii = 0; ii < bitCount; ii += 8) {
      var cc = Math.floor(ii/5)
      switch (ii % 5) {
	     case 0: buf[ii/8] = (((runes.indexOf(encoded[cc]) % 32) & 0x1F) << 3) | (((runes.indexOf(encoded[cc+1]) % 32) & 0x1C) >> 2); break; // 5 & 3
	     case 1: buf[ii/8] = (((runes.indexOf(encoded[cc]) % 32) & 0x0F) << 4) | (((runes.indexOf(encoded[cc+1]) % 32) & 0x1E) >> 1); break; // 4 & 4
	     case 2: buf[ii/8] = (((runes.indexOf(encoded[cc]) % 32) & 0x07) << 5) | (((runes.indexOf(encoded[cc+1]) % 32) & 0x1F) >> 0); break; // 3 & 5
	     case 3: buf[ii/8] = (((runes.indexOf(encoded[cc]) % 32) & 0x03) << 6) | (((runes.indexOf(encoded[cc+1]) % 32) & 0x1F) << 1) | (((runes.indexOf(encoded[cc+2]) % 32) & 0x10) >> 4); break; // 2 & 5 & 1
	     case 4: buf[ii/8] = (((runes.indexOf(encoded[cc]) % 32) & 0x01) << 7) | (((runes.indexOf(encoded[cc+1]) % 32) & 0x1F) << 2) | (((runes.indexOf(encoded[cc+2]) % 32) & 0x18) >> 3); break; // 1 & 5 & 2
	  }
   }
   return buf;
}

function getCounter(s) {
  var buf = new Uint8Array(8);
  s = Math.floor(s)
  buf[7] = Math.floor(s/1) & 0xFF;
  buf[6] = Math.floor(s/256) & 0xFF;
  buf[5] = Math.floor(s/(256*256)) & 0xFF;
  buf[4] = Math.floor(s/(256*256*256)) & 0xFF;
  buf[3] = Math.floor(s/(256*256*256*256)) & 0xFF;
  buf[2] = Math.floor(s/(256*256*256*256*256)) & 0xFF;
  buf[1] = Math.floor(s/(256*256*256*256*256*256)) & 0xFF;
  buf[0] = Math.floor(s/(256*256*256*256*256*256*256)) & 0xFF;
  return buf;
}

function getTimeCounter(windowSize) {
  const epoch = Math.round(new Date().getTime() / 1000.0)
  return getCounter(epoch / windowSize);
}

function getRemaining(windowSize) {
  const epoch = Math.round(new Date().getTime() / 1000.0)
  return windowSize - (epoch % windowSize + 1)
}

async function getOTP(secret, mac, codeLen, windowSize) {
  const keyData = decodeBuf(secret)
  const data = getTimeCounter(windowSize)
  
  if (keyData.length != 0) {
	  const key = await crypto.subtle.importKey('raw', keyData, {name: 'HMAC', hash: mac}, false, ['sign'])
	  const signature = await crypto.subtle.sign({name: 'HMAC', hash: mac}, key, data)

	  var arr = new Uint8Array(signature)
	  var offset = arr[arr.length - 1] & 0xf
	  var binary = ((arr[offset] & 0x7f) << 24) | ((arr[offset + 1] & 0xff) << 16) | ((arr[offset + 2] & 0xff) << 8) | (arr[offset + 3] & 0xff);
    return (binary % Math.pow(10, codeLen)).toString().padStart(codeLen, "0");
  } else {
	  return '';
  }
}

function generateSecret() {
  var randBytes = new Uint8Array(20)        
  window.crypto.getRandomValues(randBytes)
  document.getElementById('secret').value = encodeBuf(randBytes)
}

function refreshSecret() {
  newSecret = document.getElementById('secret').value;
  var re = new RegExp(/^otpauth:\/\/totp\/[^?]+\?/)
  if (re.test(newSecret)) {
	  var params = newSecret.substr(re.exec(newSecret)[0].length).split('&')
	  for (var ii = 0; ii < params.length; ii++) {
		  if (params[ii].startsWith('secret=')) {
			  document.getElementById('secret').value = params[ii].substr('secret='.length);
		  } else if (params[ii].startsWith('algorithm=')) {
			  var algorithm = params[ii].substr('algorithm='.length);
			  if (algorithm === 'SHA1') {
				  document.getElementById('hmac').value = 'SHA-1'
			  } else if (algorithm === 'SHA256') {
				  document.getElementById('hmac').value = 'SHA-256'
			  } else if (algorithm === 'SHA512') {
				  document.getElementById('hmac').value = 'SHA-512'
			  }
		  } else if (params[ii].startsWith('digits=')) {
			  var digits = parseInt(params[ii].substr('digits='.length))
			  document.getElementById('codeLen').value = digits
		  } else if (params[ii].startsWith('period=')) {
			  var period = parseInt(params[ii].substr('period='.length))
			  document.getElementById('windowSize').value = period
		  }
	  }
  } else {
	  document.getElementById('secret').value = newSecret;
  }
}

function refresh() {
  const windowSize = parseInt(document.getElementById('windowSize').value, 10)
  const codeLen = parseInt(document.getElementById('codeLen').value, 10)
  const mac = document.getElementById('hmac').value
  getOTP(document.getElementById('secret').value, mac, codeLen, windowSize).then(code => {document.getElementById('code').innerText = code}).catch(alert)
  var remaining = getRemaining(windowSize)
  document.getElementById('remaining').innerText = remaining;
}

function refreshRemaining() {
  const windowSize = parseInt(document.getElementById('windowSize').value, 10)
  var remaining = getRemaining(windowSize)
  document.getElementById('remaining').innerText = remaining;
  if (remaining == windowSize - 1) refresh()
}

generateSecret()
document.getElementById('secret').addEventListener('change', e => refreshSecret())
document.getElementById('windowSize').addEventListener('change', e => refresh())
document.getElementById('codeLen').addEventListener('change', e => refresh())
document.getElementById('hmac').addEventListener('change', e => refresh())
setInterval(() => refreshRemaining(), 1000)
refresh()
        </script>
    </body>
</html>